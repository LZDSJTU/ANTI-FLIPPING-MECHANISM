clear
clc

% -------------------------------规定固定参数---------------------------
% D-H参数向量，建议计算时以实际数值代入
d=[0.29; 0.0; 0.0; 0.302; 0; 0.072];
a=[0.0; 0.27; 0.07; 0.0; 0.0; 0.0];
alpha=[pi/2; 0; pi/2; pi/2; -pi/2; 0];
% 机械臂质量向量,建议计算时以具体数值代入，单位kg
density=1.3871516;
m=[3.067; 3.909; 2.944; 1.328; 0.547; 0.014]*density;
% 定义基座base的质量
mb=6.21502*density;
% 规定坐标系i的原点到质心Ci的向量,这里的c1至c6很有可能为负值，其中c5为0
rc=[0, -168.76, -12.09, 0, 0, 0 ; -51.59, 0, 0, -77.3, 0, 0 ; 0, 0, 22.81, 0, -1.1, -7.06]*1e-3;
% 建立IRB120的D-H参数矩阵
L(1)=Link('d',d(1),'a',a(1),'alpha',alpha(1),'m',m(1),'r',rc(:,1));
L(2)=Link('d',d(2),'a',a(2),'alpha',alpha(2),'m',m(2),'r',rc(:,2));
L(3)=Link('d',d(3),'a',a(3),'alpha',alpha(3),'m',m(3),'r',rc(:,3));
L(4)=Link('d',d(4),'a',a(4),'alpha',alpha(4),'m',m(4),'r',rc(:,4));
L(5)=Link('d',d(5),'a',a(5),'alpha',alpha(5),'m',m(5),'r',rc(:,5));
L(6)=Link('d',d(6),'a',a(6),'alpha',alpha(6),'m',m(6),'r',rc(:,6));
% 建立机器人
IRB120=SerialLink(L,'name','IRB120');

% -------------------------------规定固定参数完---------------------------


% -------------------------------规定初始输入参数---------------------------
% 定义移动平台的尺寸和重量，长度用LEN原因：L为机械臂连杆参数，重叠，故用LEN
LEN=0.5;
W=0.6;
H=0.2;
M=102.52;
% 规定移动平台重心位置
pm=[0; 0; -H/2];
% 规定机械臂在移动平台上的安装位置
pb=[0; 0; 0];
% 定义基座质心相对于底部圆心的向量
rb=[-42.04; 0.08; 79.64]*1e-3;
rb=pb+rb;
%规定机械臂各关节的角度
q=[0, pi/4, -pi/4, 0, 0, 0];

% -------------------------------规定初始输入参数完---------------------------


% 计算每个关节对应的齐次变换矩阵
T(1:4,1:4,1)=L(1).A(q(1));
for i=2:6
    T(:,:,i)=T(:,:,i-1)*L(i).A(q(i));
end
% 根据齐次变换矩阵得到每个关节的空间三维坐标
for i=1:6
    p(1:3,i)=T(1:3,4,i);
end
% 根据每个连杆的端点坐标，得到连杆质心坐标
for i=1:6
   pc(1:3,i)=p(1:3,i)+T(1:3,1:3,i)*rc(1:3,i);
end
% 将质心坐标由机器人坐标系转换为支撑多边形坐标系
for i=1:6
   pc(1:3,i)=pc(1:3,i)+pb;
end

% 计算总重及质心位置
Mtotal=m(1)+m(2)+m(3)+m(4)+m(5)+m(6)+mb+M;
C=(m(1)*pc(1:3,1)+m(2)*pc(1:3,2)+m(3)*pc(1:3,3)+m(4)*pc(1:3,4)+m(5)*pc(1:3,5)+m(6)*pc(1:3,6))/(Mtotal-M-mb);
COG=(C*(Mtotal-M-mb)+M*pm+mb*rb)/Mtotal;
display(COG);

% 规定操作空间范围，并作图
s=[-1.2 0.8 -0.8 0.8 -0.3 0.8];
IRB120.plot(q,'workspace',s,'fps',10);
hold on
x=[-LEN/2,LEN/2,LEN/2,-LEN/2,-LEN/2;-LEN/2,LEN/2,LEN/2,-LEN/2,-LEN/2];
y=[-W/2,-W/2,W/2,W/2,-W/2;-W/2,-W/2,W/2,W/2,-W/2];
z=[0,0,0,0,0;-H,-H,-H,-H,-H];
mesh(x,y,z)
colormap(gray(1));
xlabel('x');ylabel('y');zlabel('z')

if abs(COG(1))>LEN/2||abs(COG(2))>W/2
    display('倾覆');
else
    display('不倾覆');
    d1=min(COG(1)+LEN/2,LEN/2-COG(1));
    d2=min(COG(2)+W/2,W/2-COG(2));
    dmin=min(d1,d2)
end

% 画出支撑多边形的区域,并将重心投影点标记出来
figure(2);
plot([-LEN/2,LEN/2,LEN/2,-LEN/2,-LEN/2],[-W/2,-W/2,W/2,W/2,-W/2]);
axis([-2*LEN 2*LEN -2*W 2*W]);
axis square
hold on;
plot(COG(1),COG(2),'*');
% hold on;
% plot(C(1),C(2),'*');
% hold on
% plot(pb(1),pb(2),'*');


